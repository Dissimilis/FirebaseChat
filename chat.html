<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script src="https://cdn.firebase.com/js/client/2.2.1/firebase.js" integrity="sha384-zAlH3FrzsxdG1VfzWcyO9+PqCx5mQkLQPjgtp7jukmrbywGDj5nCivAb4j9ddOFu" crossorigin="anonymous"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.2/styles/tomorrow-night.min.css" integrity="sha256-j9z54bBKr1YuuulDV9S89E6WbTjElOrGGWyJy3N0xS8=" crossorigin="anonymous" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.2/highlight.min.js" integrity="sha256-xBWd+VDTBasaTja2bfaCX4aA2H18UxRsjRFkK3rgfkI=" crossorigin="anonymous"></script>
		<style>
			:root {
				--bg-primary: #0d1117;
				--bg-message: #161b22;
				--bg-message-alt: #1c2128;
				--text-primary: #e6edf3;
				--text-secondary: #8b949e;
				--text-nick: #58a6ff;
				--text-time: #8b949e;
				--accent: #3fb950;
				--border: #30363d;
				--input-bg: #21262d;
			}
			*, *::before, *::after { box-sizing: border-box; }
			html, body {
				height: 100%;
				margin: 0;
				padding: 0;
				background: var(--bg-primary);
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
				font-size: 1rem;
				line-height: 1.5;
				color: var(--text-primary);
			}
			.app {
				display: flex;
				flex-direction: column;
				height: 100dvh;
			}
			#messages {
				flex: 1;
				overflow-y: auto;
				scroll-behavior: smooth;
				padding: 0.5rem;
			}
			#messages[aria-live] { /* specificity bump for aria attribute */ }
			#inputs-container {
				flex-shrink: 0;
				background: var(--bg-primary);
				border-top: 1px solid var(--border);
				padding: 0.5rem;
			}
			#inputs { display: flex; flex-direction: column; gap: 0.4rem; }
			#options {
				display: none;
				flex-direction: column;
				gap: 0.4rem;
				padding-bottom: 0.4rem;
			}
			#options label {
				color: var(--text-secondary);
				cursor: pointer;
				user-select: none;
			}
			#options input[type="text"],
			#options input[type="password"] {
				width: 100%;
			}
			#notificationsConfig {
				display: flex;
				flex-direction: column;
				gap: 0.4rem;
			}
			#notificationsConfig .option-row {
				display: flex;
				align-items: center;
				gap: 0.4rem;
			}
			#cryptoStatus {
				display: none;
				color: #f0b35a;
				font-size: 0.85rem;
			}
			#msgInput {
				display: flex;
				gap: 0.4rem;
				align-items: flex-end;
			}
			#msgInput.drag-over #messageInput {
				border-color: var(--accent);
				box-shadow: 0 0 0 1px color-mix(in srgb, var(--accent) 50%, transparent);
			}
			#pendingAttachment {
				display: none;
				align-items: center;
				justify-content: space-between;
				gap: 0.4rem;
				padding: 0.35rem 0.5rem;
				border: 1px solid var(--border);
				border-radius: 0.375rem;
				background: var(--input-bg);
				color: var(--text-secondary);
				font-size: 0.85rem;
			}
			#pendingAttachmentName {
				min-width: 0;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}
			#clearAttachment {
				padding: 0.2rem 0.45rem;
				font-size: 0.8rem;
			}
			#optionsToggle {
				color: var(--text-secondary);
				cursor: pointer;
				font-size: 1.2rem;
				padding: 0.3rem 0.5rem;
				border-radius: 0.25rem;
				user-select: none;
				line-height: 1;
			}
			#optionsToggle:hover, #optionsToggle:focus-visible {
				color: var(--text-primary);
				background: var(--input-bg);
				outline: none;
			}
			#messageInput {
				flex: 1;
				min-height: 2.5rem;
				max-height: 8rem;
				resize: none;
				padding: 0.4rem 0.6rem;
				font-size: 0.95rem;
				line-height: 1.4;
				background: var(--input-bg);
				color: var(--text-primary);
				border: 1px solid var(--border);
				border-radius: 0.375rem;
				font-family: inherit;
			}
			#messageInput:focus {
				outline: none;
				border-color: var(--text-nick);
			}
			input[type="text"], input[type="password"] {
				background: var(--input-bg);
				color: var(--text-primary);
				border: 1px solid var(--border);
				border-radius: 0.375rem;
				padding: 0.35rem 0.6rem;
				font-size: 0.9rem;
				font-family: inherit;
			}
			input[type="text"]:focus, input[type="password"]:focus {
				outline: none;
				border-color: var(--text-nick);
			}
			input[type="checkbox"] {
				accent-color: var(--accent);
			}
			button {
				background: var(--input-bg);
				color: var(--text-primary);
				border: 1px solid var(--border);
				border-radius: 0.375rem;
				padding: 0.4rem 0.8rem;
				font-size: 0.9rem;
				cursor: pointer;
				font-family: inherit;
			}
			button:hover {
				background: var(--border);
			}
			#send {
				padding: 0.4rem 1rem;
				font-size: 0.9rem;
				line-height: 1.4;
				white-space: nowrap;
			}
			#attach {
				padding: 0.4rem 0.8rem;
				white-space: nowrap;
			}
			/* Messages */
			.msg {
				display: flex;
				gap: 0.5rem;
				padding: 0.15rem 0.4rem;
				background: var(--bg-message);
			}
			.msg.alternate {
				background: var(--bg-message-alt);
			}
			.msg.new { margin-top: 0.25rem; }
			.msg.same { border-radius: 0; }
			.msg.enc {
				border-left: 2px solid var(--accent);
				background: color-mix(in srgb, var(--accent) 4%, var(--bg-message));
			}
			.msg.enc.alternate {
				background: color-mix(in srgb, var(--accent) 4%, var(--bg-message-alt));
			}
			.nickname {
				flex-shrink: 0;
				min-width: 4rem;
				color: var(--text-nick);
				text-align: right;
				font-weight: 600;
				font-size: 0.9rem;
			}
			.msg.same .nickname { visibility: hidden; }
			.msg.new .nickname { display: inline-block; }
			.msgBody {
				flex: 1;
				min-width: 0;
				color: var(--text-primary);
				word-wrap: break-word;
				overflow-wrap: break-word;
			}
			.msgBody img {
				max-height: 300px;
				width: auto;
				border: 1px solid var(--border);
				border-radius: 0.25rem;
				margin: 0.25rem 0;
			}
			.msg .time {
				color: var(--text-time);
				font-size: 0.7rem;
				margin: 0;
			}
			.msg pre { margin-top: 0.3rem; padding: 0; }
			.msg code.snip {
				background: #30363d;
				color: #e6edf3;
				padding: 0.1rem 0.3rem;
				border-radius: 0.2rem;
				font-size: 0.9em;
			}
			.msgAttachment {
				display: flex;
				flex-direction: column;
				gap: 0.3rem;
				margin-top: 0.35rem;
				padding: 0.4rem 0.5rem;
				border: 1px solid var(--border);
				border-radius: 0.35rem;
				background: color-mix(in srgb, var(--bg-message-alt) 92%, black 8%);
			}
			.msgAttachmentName {
				font-size: 0.9rem;
				font-weight: 600;
				color: var(--text-primary);
				word-break: break-word;
			}
			.msgAttachmentMeta {
				font-size: 0.75rem;
				color: var(--text-secondary);
				word-break: break-word;
			}
			.msgAttachmentAction {
				font-size: 0.8rem;
			}
			.msgAttachmentAction a {
				color: var(--text-nick);
				text-decoration: none;
			}
			.msgAttachmentAction a:hover {
				text-decoration: underline;
			}
			.msgInlineAttachment {
				margin-top: 0.35rem;
				display: flex;
				flex-direction: column;
				gap: 0.25rem;
			}
			.msgInlineAttachment .msgAttachmentThumb img {
				max-width: 240px;
				max-height: 180px;
			}
			.msgAttachmentThumbWrap {
				margin-top: 0.2rem;
			}
			.msgAttachmentThumb {
				display: inline-block;
				padding: 0;
				background: transparent;
				border: 0;
				cursor: zoom-in;
			}
			.msgAttachmentThumb img {
				display: block;
				max-width: 180px;
				max-height: 120px;
				width: auto;
				height: auto;
				border: 1px solid var(--border);
				border-radius: 0.25rem;
			}
			#imagePreviewOverlay {
				position: fixed;
				inset: 0;
				display: none;
				align-items: center;
				justify-content: center;
				background: rgba(0, 0, 0, 0.82);
				z-index: 1200;
				padding: 1rem;
			}
			#imagePreviewDialog {
				position: relative;
				max-width: 96vw;
				max-height: 92vh;
				overflow: auto;
				background: #0b0f14;
				border: 1px solid var(--border);
				border-radius: 0.4rem;
				padding: 0.5rem;
			}
			#imagePreviewImage {
				display: block;
				max-width: none;
				max-height: none;
				width: auto;
				height: auto;
			}
			#imagePreviewMeta {
				margin-top: 0.45rem;
				color: var(--text-secondary);
				font-size: 0.8rem;
			}
			#imagePreviewClose {
				position: absolute;
				top: 0.3rem;
				right: 0.3rem;
				padding: 0.2rem 0.45rem;
				font-size: 0.85rem;
				line-height: 1;
			}
			img {
				max-width: 100%;
				max-height: 100%;
			}
			#secureIcon {
				position: fixed;
				top: 0.4rem;
				right: 0.8rem;
				font-size: 1.5rem;
				display: none;
			}
			hr { margin: 0.2rem; border-color: var(--border); }
			/* Scrollbar */
			#messages::-webkit-scrollbar { width: 8px; }
			#messages::-webkit-scrollbar-track { background: var(--bg-primary); }
			#messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
		</style>
		<title>Chat</title>
	</head>
	<body>
		<div class="app">
			<div id="messages" aria-live="polite"></div>
			<div id="inputs-container">
				<div id="inputs">
					<div id="options">
						<input value="" id="nameInput" placeholder="Name" type="text" aria-label="Nickname">
						<div id="notificationsConfig">
							<input value="" type="password" id="passwordInput" placeholder="Encryption password" aria-label="Encryption password">
							<button id="persistPass" title="Persist derived unlock secret to survive refresh">Save key</button>
							<div class="option-row">
								<input type="checkbox" id="enableEncryption"> <label for="enableEncryption">Enable encryption</label>
							</div>
							<div class="option-row">
								<input type="checkbox" id="enableNotifications"> <label for="enableNotifications">Enable notifications</label>
							</div>
						</div>
						<div id="cryptoStatus"></div>
					</div>
					<div id="msgInput">
						<div id="optionsToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="options" title="Toggle options">&#x2699;</div>
						<textarea id="messageInput" placeholder="Message" rows="1"></textarea>
						<button id="attach" type="button">Attach</button>
						<button id="send">Send</button>
					</div>
					<input id="fileInput" type="file" style="display:none;" />
					<div id="pendingAttachment">
						<span id="pendingAttachmentName"></span>
						<button id="clearAttachment" type="button">Clear</button>
					</div>
				</div>
			</div>
			<div id="secureIcon" style="display:none;">&#x1F512;</div>
		</div>
		<div id="imagePreviewOverlay" aria-hidden="true">
			<div id="imagePreviewDialog" role="dialog" aria-modal="true" aria-label="Image preview">
				<button id="imagePreviewClose" type="button" aria-label="Close image preview">X</button>
				<img id="imagePreviewImage" alt="Attachment preview" />
				<div id="imagePreviewMeta"></div>
			</div>
		</div>
		<script>
(function() {
'use strict';

/* ===== CONFIGURATION ===== */
const databaseUrl = 'https://antano-chatas.firebaseio.com/';
const messagesLimit = 147;
const notificationsEnabled = true;
const encVersion = 1;
const encAlgorithm = 'AES-256-GCM';
const encKdf = 'PBKDF2-SHA-256';
const pbkdf2Iterations = 310000;
const maxAcceptedPbkdf2Iterations = 400000;
const persistTransformSalt = 'firebasechat-passphrase-persist-v1';
const persistTransformIterations = 120000;
const encSaltLengthBytes = 16;
const encIvLengthBytes = 12;
const maxAttachmentBytes = 200 * 1024;
const maxAttachmentBase64Length = Math.ceil((maxAttachmentBytes * 4) / 3) + 8;
const maxAttachmentCount = 1;
const pastedJpegQuality = 0.77;

/* ===== STATE ===== */
const fb = new Firebase(databaseUrl);
const fbQuery = fb.endAt().limitToLast(messagesLimit);
const supportsModernCrypto = !!(window.crypto && window.crypto.subtle && window.TextEncoder && window.TextDecoder);
const title = "Chat";
let lastName = "";
let notifyEnabled = false;
let password;
let passwordFallback;
let encrypt = false;
let decryptFailureCount = 0;
let cryptoStatusMessage = "";
let messageRenderQueue = Promise.resolve();
let attachGeneration = 0;
let pendingAttachment = null;
let dragDepth = 0;
let imagePreviewOpen = false;
let unreadMsgCount = 0;
let notificationWarmupExpiresAt = 0;
document.title = title;

/* ===== DOM REFERENCES ===== */
const $messages = document.getElementById('messages');
const $nameInput = document.getElementById('nameInput');
const $passwordInput = document.getElementById('passwordInput');
const $messageInput = document.getElementById('messageInput');
const $enableEncryption = document.getElementById('enableEncryption');
const $enableNotifications = document.getElementById('enableNotifications');
const $secureIcon = document.getElementById('secureIcon');
const $cryptoStatus = document.getElementById('cryptoStatus');
const $options = document.getElementById('options');
const $optionsToggle = document.getElementById('optionsToggle');
const $msgInput = document.getElementById('msgInput');
const $sendBtn = document.getElementById('send');
const $attachBtn = document.getElementById('attach');
const $fileInput = document.getElementById('fileInput');
const $pendingAttachment = document.getElementById('pendingAttachment');
const $pendingAttachmentName = document.getElementById('pendingAttachmentName');
const $clearAttachment = document.getElementById('clearAttachment');
const $persistPass = document.getElementById('persistPass');
const $imagePreviewOverlay = document.getElementById('imagePreviewOverlay');
const $imagePreviewClose = document.getElementById('imagePreviewClose');
const $imagePreviewImage = document.getElementById('imagePreviewImage');
const $imagePreviewMeta = document.getElementById('imagePreviewMeta');

/* ===== UTILITIES ===== */
function escapeHtml(txt) {
	return txt
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#39;");
}

function formatBytes(bytes) {
	if (bytes < 1024) return bytes + " B";
	if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
	return (bytes / (1024 * 1024)).toFixed(2) + " MB";
}

function formatText(txt) {
	if (txt === null || txt === undefined) {
		return "";
	}
	txt = String(txt);
	if (txt.startsWith("`")) {
		txt = txt.replace(/^`|`$/g, "");
		txt = txt.replace(/^\s+|\s+$/g, '');
		return `<pre><code>${escapeHtml(txt)}</code></pre>`;
	}
	txt = escapeHtml(txt);
	const codeExp = /`(.+?)`/gi;
	if (txt.search(codeExp) >= 0) {
		return txt.replace(codeExp, '<code class="snip">$1</code>');
	}
	const imgExp = /(\b(https?):.+?\.(jpg|gif|png|svg|jpeg))/gi;
	const linkExp = /(\b(https?):[^ ]+)/gi;
	txt = txt.split("\n").join("<br />");
	if (txt.search(imgExp) >= 0) {
		return txt.replace(imgExp, '<a href="$1" target="_blank"><img src="$1" /></a>');
	}
	txt = txt.replace(linkExp, '<a href="$1" target="_blank">$1</a>');
	return txt;
}

function sanitizeFileName(name) {
	const cleaned = (name || "").trim();
	if (!cleaned) {
		return "attachment.bin";
	}
	return cleaned;
}

function hasDraggedFiles(e) {
	const dt = e.dataTransfer;
	if (!dt) {
		return false;
	}
	if (dt.types && dt.types.length) {
		for (let i = 0; i < dt.types.length; i++) {
			if (dt.types[i] === 'Files') {
				return true;
			}
		}
	}
	return !!(dt.files && dt.files.length);
}

function isImageAttachment(file) {
	return !!(file && typeof file.type === "string" && /^image\//i.test(file.type));
}

function base64ByteLength(base64) {
	if (!base64) {
		return 0;
	}
	const len = base64.length;
	let padding = 0;
	if (len >= 2) {
		if (base64.charAt(len - 1) === '=') padding += 1;
		if (base64.charAt(len - 2) === '=') padding += 1;
	}
	return Math.floor((len * 3) / 4) - padding;
}

function safeMimeType(mime) {
	if (typeof mime !== "string") {
		return "application/octet-stream";
	}
	const trimmed = mime.trim().toLowerCase();
	if (/^[a-z0-9!#$&^_.+-]+\/[a-z0-9!#$&^_.+-]+$/.test(trimmed)) {
		return trimmed;
	}
	return "application/octet-stream";
}

function attachmentDataUrl(file) {
	return `data:${safeMimeType(file.type)};base64,${file.data}`;
}

function createElement(tag, className, textContent) {
	const el = document.createElement(tag);
	if (className) el.className = className;
	if (textContent) el.textContent = textContent;
	return el;
}

/* ===== CRYPTO ===== */
function utf8ToBytes(txt) {
	return new TextEncoder().encode(txt);
}

function bytesToUtf8(bytes) {
	return new TextDecoder().decode(bytes);
}

function randomBytes(length) {
	const bytes = new Uint8Array(length);
	window.crypto.getRandomValues(bytes);
	return bytes;
}

function toBase64(bytes) {
	let binary = "";
	const chunkSize = 0x8000;
	for (let i = 0; i < bytes.length; i += chunkSize) {
		const chunk = bytes.subarray(i, i + chunkSize);
		binary += String.fromCharCode.apply(null, chunk);
	}
	return btoa(binary);
}

function fromBase64(base64) {
	const binary = atob(base64);
	const bytes = new Uint8Array(binary.length);
	for (let i = 0; i < binary.length; i++) {
		bytes[i] = binary.charCodeAt(i);
	}
	return bytes;
}

async function deriveAesKey(passphrase, saltBytes, iterations) {
	const keyMaterial = await window.crypto.subtle.importKey(
		'raw',
		utf8ToBytes(passphrase),
		'PBKDF2',
		false,
		['deriveKey']
	);
	return window.crypto.subtle.deriveKey(
		{
			name: 'PBKDF2',
			salt: saltBytes,
			iterations: iterations,
			hash: 'SHA-256'
		},
		keyMaterial,
		{
			name: 'AES-GCM',
			length: 256
		},
		false,
		['encrypt', 'decrypt']
	);
}

async function derivePersistedSecret(rawPassphrase) {
	const keyMaterial = await window.crypto.subtle.importKey(
		'raw',
		utf8ToBytes(rawPassphrase),
		'PBKDF2',
		false,
		['deriveBits']
	);
	const secretBits = await window.crypto.subtle.deriveBits(
		{
			name: 'PBKDF2',
			salt: utf8ToBytes(persistTransformSalt),
			iterations: persistTransformIterations,
			hash: 'SHA-256'
		},
		keyMaterial,
		256
	);
	return toBase64(new Uint8Array(secretBits));
}

async function encryptPayloadV1(payload, passphrase) {
	const plainText = JSON.stringify(payload);
	const salt = randomBytes(encSaltLengthBytes);
	const iv = randomBytes(encIvLengthBytes);
	const key = await deriveAesKey(passphrase, salt, pbkdf2Iterations);
	const encryptedBuffer = await window.crypto.subtle.encrypt(
		{ name: 'AES-GCM', iv: iv },
		key,
		utf8ToBytes(plainText)
	);
	return {
		text: "This message is encrypted",
		enc: {
			v: encVersion,
			alg: encAlgorithm,
			kdf: encKdf,
			iter: pbkdf2Iterations,
			salt: toBase64(salt),
			iv: toBase64(iv),
			ct: toBase64(new Uint8Array(encryptedBuffer))
		}
	};
}

async function decryptTextV1(encObj, passphrase) {
	if (!encObj || encObj.v !== encVersion || encObj.alg !== encAlgorithm || encObj.kdf !== encKdf) {
		throw new Error("Unsupported encryption payload");
	}
	const iterations = Number(encObj.iter);
	if (!isFinite(iterations) || iterations <= 0 || iterations !== Math.floor(iterations) || iterations > maxAcceptedPbkdf2Iterations) {
		throw new Error("Invalid KDF iteration count");
	}
	const salt = fromBase64(encObj.salt);
	const iv = fromBase64(encObj.iv);
	const ciphertext = fromBase64(encObj.ct);
	const key = await deriveAesKey(passphrase, salt, iterations);
	const decryptedBuffer = await window.crypto.subtle.decrypt(
		{ name: 'AES-GCM', iv: iv },
		key,
		ciphertext
	);
	return bytesToUtf8(new Uint8Array(decryptedBuffer));
}

/* ===== PASSWORD MANAGEMENT ===== */
function hasPersistedSplitSecret() {
	return !!(localStorage.getItem("p") && window.location.hash);
}

function resolvePersistedSecret() {
	const localHalf = localStorage.getItem("p");
	let hashHalf = "";
	if (window.location.hash) {
		try {
			hashHalf = decodeURIComponent(window.location.hash.substring(1));
		} catch (err) {
			hashHalf = "";
		}
	}
	if (!localHalf || !hashHalf) {
		return "";
	}
	return localHalf + hashHalf;
}

async function resolveActivePassword() {
	const userpass = $passwordInput.value;
	if (userpass) {
		return {
			primary: await derivePersistedSecret(userpass),
			fallback: userpass
		};
	}
	const persistedSecret = resolvePersistedSecret();
	if (persistedSecret) {
		return {
			primary: persistedSecret,
			fallback: ""
		};
	}
	return null;
}

async function enableEncryption() {
	if (!supportsModernCrypto) {
		encrypt = false;
		password = undefined;
		passwordFallback = undefined;
		$enableEncryption.checked = false;
		$secureIcon.style.display = 'none';
		setCryptoStatusMessage("Modern encryption is not supported in this browser.");
		return;
	}

	try {
		const resolvedPassword = await resolveActivePassword();
		if (!resolvedPassword) {
			encrypt = false;
			password = undefined;
			passwordFallback = undefined;
			$enableEncryption.checked = false;
			$secureIcon.style.display = 'none';
			setCryptoStatusMessage("Enter an encryption password first.");
			return;
		}

		password = resolvedPassword.primary;
		passwordFallback = resolvedPassword.fallback || undefined;
		setCryptoStatusMessage("");
		resetDecryptFailures();
		$secureIcon.style.display = '';
		fb.off();
		$messages.innerHTML = '';
		encrypt = true;
		fbAttach();
	} catch (err) {
		console.log(err);
		encrypt = false;
		password = undefined;
		passwordFallback = undefined;
		$enableEncryption.checked = false;
		$secureIcon.style.display = 'none';
		setCryptoStatusMessage("Failed to initialize encryption.");
	}
}

async function persistDerivedSecret() {
	if (!supportsModernCrypto) {
		setCryptoStatusMessage("Modern encryption is not supported in this browser.");
		return;
	}
	try {
		const resolved = await resolveActivePassword();
		if (!resolved || !resolved.primary) {
			setCryptoStatusMessage("Enter an encryption password first.");
			return;
		}
		password = resolved.primary;
		passwordFallback = resolved.fallback || undefined;
		const half = Math.floor(password.length / 2);
		localStorage.setItem("p", password.substring(0, half));
		window.location.hash = encodeURIComponent(password.substring(half));
		setCryptoStatusMessage("Derived unlock secret persisted.");
	} catch (err) {
		console.log(err);
		setCryptoStatusMessage("Failed to persist unlock secret.");
	}
}

/* ===== ATTACHMENTS ===== */
function readFileAsAttachment(file) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => {
			try {
				const bytes = new Uint8Array(reader.result);
				resolve({
					name: sanitizeFileName(file.name),
					type: file.type || "application/octet-stream",
					size: bytes.length,
					data: toBase64(bytes)
				});
			} catch (err) {
				reject(err);
			}
		};
		reader.onerror = () => {
			reject(reader.error || new Error("File read failed"));
		};
		reader.readAsArrayBuffer(file);
	});
}

async function handleFileSelection(files, fromDrop) {
	if (!files || !files.length) {
		return;
	}
	if (files.length > maxAttachmentCount) {
		setCryptoStatusMessage("Only one attachment per message is supported.");
		return;
	}
	const file = files[0];
	if (!file) {
		return;
	}
	if (file.size > maxAttachmentBytes) {
		setCryptoStatusMessage(`Attachment exceeds max size (${formatBytes(maxAttachmentBytes)}).`);
		return;
	}
	try {
		pendingAttachment = await readFileAsAttachment(file);
		renderPendingAttachment();
		if (fromDrop) {
			setCryptoStatusMessage("Attachment ready.");
		} else {
			setCryptoStatusMessage("");
		}
	} catch (err) {
		console.log(err);
		setCryptoStatusMessage("Failed to read attachment.");
	}
}

async function handlePasteAttachment(e) {
	if (!e.clipboardData || !e.clipboardData.items) {
		return;
	}
	const items = e.clipboardData.items;
	let imageFile = null;
	for (let i = 0; i < items.length; i++) {
		const item = items[i];
		if (item && item.kind === "file" && item.type && item.type.indexOf("image/") === 0) {
			imageFile = item.getAsFile();
			break;
		}
	}
	if (!imageFile) {
		return;
	}
	e.preventDefault();
	try {
		const jpegAttachment = await recompressPastedImageToJpeg(imageFile);
		if (jpegAttachment.size > maxAttachmentBytes) {
			setCryptoStatusMessage(`Pasted image exceeds max size (${formatBytes(maxAttachmentBytes)}).`);
			return;
		}
		pendingAttachment = jpegAttachment;
		renderPendingAttachment();
		setCryptoStatusMessage(`Image pasted and attached (JPEG quality ${Math.round(pastedJpegQuality * 100)}%).`);
	} catch (err) {
		console.log(err);
		setCryptoStatusMessage("Failed to process pasted image.");
	}
}

function sanitizeIncomingAttachment(file) {
	if (!file || typeof file !== "object") {
		return null;
	}
	const data = typeof file.data === "string" ? file.data : "";
	const size = Number(file.size);
	if (!data || !isFinite(size) || size <= 0 || size > maxAttachmentBytes) {
		return null;
	}
	if (data.length > maxAttachmentBase64Length) {
		return null;
	}
	if (!/^[A-Za-z0-9+/=]+$/.test(data)) {
		return null;
	}
	const decodedBytes = base64ByteLength(data);
	if (decodedBytes <= 0 || decodedBytes > maxAttachmentBytes || Math.abs(decodedBytes - size) > 4) {
		return null;
	}
	return {
		name: sanitizeFileName(file.name),
		type: (typeof file.type === "string" && file.type) ? file.type : "application/octet-stream",
		size: Math.floor(size),
		data: data
	};
}

function parseDecryptedPayload(decryptedText) {
	if (decryptedText === null || decryptedText === undefined) {
		return { text: "", file: null };
	}
	try {
		const parsed = JSON.parse(decryptedText);
		if (parsed && typeof parsed === "object" && (Object.prototype.hasOwnProperty.call(parsed, "text") || Object.prototype.hasOwnProperty.call(parsed, "file"))) {
			return {
				text: parsed.text === undefined || parsed.text === null ? "" : String(parsed.text),
				file: sanitizeIncomingAttachment(parsed.file)
			};
		}
	} catch (err) {
		// Keep compatibility with old encrypted text-only payloads.
	}
	return { text: String(decryptedText), file: null };
}

function getPastedImageName() {
	const now = new Date();
	const stamp = now.getFullYear().toString()
		+ String(now.getMonth() + 1).padStart(2, '0')
		+ String(now.getDate()).padStart(2, '0')
		+ "-"
		+ String(now.getHours()).padStart(2, '0')
		+ String(now.getMinutes()).padStart(2, '0')
		+ String(now.getSeconds()).padStart(2, '0');
	return `pasted-image-${stamp}.jpg`;
}

function fileToDataUrl(file) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => { resolve(reader.result); };
		reader.onerror = () => { reject(reader.error || new Error("Failed to read file as data URL")); };
		reader.readAsDataURL(file);
	});
}

function loadImageFromDataUrl(dataUrl) {
	return new Promise((resolve, reject) => {
		const img = new Image();
		img.onload = () => { resolve(img); };
		img.onerror = () => { reject(new Error("Failed to load pasted image")); };
		img.src = dataUrl;
	});
}

async function recompressPastedImageToJpeg(file) {
	const dataUrl = await fileToDataUrl(file);
	const img = await loadImageFromDataUrl(dataUrl);
	const originalWidth = img.naturalWidth || img.width;
	const originalHeight = img.naturalHeight || img.height;
	if (!originalWidth || !originalHeight) {
		throw new Error("Invalid pasted image dimensions");
	}
	const canvas = document.createElement('canvas');
	const ctx = canvas.getContext('2d', { alpha: false });
	if (!ctx) {
		throw new Error("Canvas context unavailable");
	}

	let width = originalWidth;
	let height = originalHeight;
	const minDimension = 64;
	const maxAttempts = 12;
	for (let attempt = 0; attempt < maxAttempts; attempt++) {
		canvas.width = width;
		canvas.height = height;
		ctx.fillStyle = '#ffffff';
		ctx.fillRect(0, 0, width, height);
		ctx.drawImage(img, 0, 0, width, height);
		const jpegDataUrl = canvas.toDataURL('image/jpeg', pastedJpegQuality);
		const idx = jpegDataUrl.indexOf(',');
		const base64 = idx >= 0 ? jpegDataUrl.substring(idx + 1) : "";
		if (!base64) {
			throw new Error("JPEG recompression failed");
		}
		const size = base64ByteLength(base64);
		if (size > 0 && size <= maxAttachmentBytes) {
			return {
				name: getPastedImageName(),
				type: "image/jpeg",
				size: size,
				data: base64
			};
		}

		if (width <= minDimension || height <= minDimension) {
			break;
		}

		let areaRatio = Math.sqrt(maxAttachmentBytes / Math.max(size, 1));
		if (!isFinite(areaRatio) || areaRatio <= 0) {
			areaRatio = 0.8;
		}
		const shrink = Math.min(0.9, Math.max(0.5, areaRatio * 0.95));
		let nextWidth = Math.max(minDimension, Math.floor(width * shrink));
		let nextHeight = Math.max(minDimension, Math.floor(height * shrink));
		if (nextWidth === width && nextHeight === height) {
			nextWidth = Math.max(minDimension, width - 64);
			nextHeight = Math.max(minDimension, height - 64);
		}
		width = nextWidth;
		height = nextHeight;
	}
	throw new Error("Pasted image exceeds max size even after resize");
}

function downloadAttachment(file) {
	const bytes = fromBase64(file.data);
	const blob = new Blob([bytes], { type: safeMimeType(file.type) });
	const url = URL.createObjectURL(blob);
	const anchor = document.createElement('a');
	anchor.href = url;
	anchor.download = sanitizeFileName(file.name);
	anchor.rel = 'noopener';
	document.body.appendChild(anchor);
	anchor.click();
	document.body.removeChild(anchor);
	setTimeout(() => { URL.revokeObjectURL(url); }, 1500);
}

/* ===== UI RENDERING ===== */
function renderPendingAttachment() {
	if (!pendingAttachment) {
		$pendingAttachmentName.textContent = "";
		$pendingAttachment.style.display = 'none';
		return;
	}
	$pendingAttachmentName.textContent = `Attached: ${pendingAttachment.name} (${formatBytes(pendingAttachment.size)})`;
	$pendingAttachment.style.display = 'flex';
}

function clearPendingAttachment() {
	pendingAttachment = null;
	renderPendingAttachment();
}

function renderCryptoStatus() {
	let msg = cryptoStatusMessage;
	if (!msg && decryptFailureCount > 0) {
		msg = `${decryptFailureCount} encrypted message(s) could not be decrypted.`;
	}
	if (msg) {
		$cryptoStatus.textContent = msg;
		$cryptoStatus.style.display = '';
	} else {
		$cryptoStatus.style.display = 'none';
		$cryptoStatus.textContent = "";
	}
}

function setCryptoStatusMessage(msg) {
	cryptoStatusMessage = msg || "";
	renderCryptoStatus();
}

function incrementDecryptFailure() {
	decryptFailureCount += 1;
	renderCryptoStatus();
}

function resetDecryptFailures() {
	decryptFailureCount = 0;
	renderCryptoStatus();
}

function createAttachmentElement(file) {
	if (!file) {
		return null;
	}
	if (isImageAttachment(file)) {
		const inlineWrap = createElement('div', 'msgInlineAttachment');
		const thumbBtn = createElement('button', 'msgAttachmentThumb');
		thumbBtn.type = 'button';
		thumbBtn.title = 'Open full size image';
		const thumbImg = document.createElement('img');
		thumbImg.alt = sanitizeFileName(file.name);
		thumbImg.src = attachmentDataUrl(file);
		thumbBtn.appendChild(thumbImg);
		thumbBtn.addEventListener('click', () => {
			openImagePreview(file);
		});
		inlineWrap.appendChild(thumbBtn);
		inlineWrap.appendChild(createElement('div', 'msgAttachmentMeta', `${sanitizeFileName(file.name)} \u2022 ${formatBytes(file.size)}`));

		const inlineAction = createElement('div', 'msgAttachmentAction');
		const viewLink = document.createElement('a');
		viewLink.href = '#';
		viewLink.textContent = 'View full size';
		viewLink.addEventListener('click', (e) => {
			e.preventDefault();
			openImagePreview(file);
		});
		inlineAction.appendChild(viewLink);
		inlineAction.appendChild(document.createTextNode(' \u2022 '));

		const inlineDownload = document.createElement('a');
		inlineDownload.href = '#';
		inlineDownload.textContent = 'Download';
		inlineDownload.addEventListener('click', (e) => {
			e.preventDefault();
			try {
				downloadAttachment(file);
			} catch (err) {
				console.log(err);
				setCryptoStatusMessage("Failed to prepare attachment download.");
			}
		});
		inlineAction.appendChild(inlineDownload);
		inlineWrap.appendChild(inlineAction);
		return inlineWrap;
	}

	const card = createElement('div', 'msgAttachment');
	card.appendChild(createElement('div', 'msgAttachmentName', file.name));
	card.appendChild(createElement('div', 'msgAttachmentMeta', `${file.type || "application/octet-stream"} \u2022 ${formatBytes(file.size)}`));
	const action = createElement('div', 'msgAttachmentAction');
	const downloadLink = document.createElement('a');
	downloadLink.href = '#';
	downloadLink.textContent = 'Download';
	downloadLink.addEventListener('click', (e) => {
		e.preventDefault();
		try {
			downloadAttachment(file);
		} catch (err) {
			console.log(err);
			setCryptoStatusMessage("Failed to prepare attachment download.");
		}
	});
	action.appendChild(downloadLink);
	card.appendChild(action);
	return card;
}

function displayChatMessage(name, text, time, encrypted, attachment) {
	const localTimeString = new Date(Date.parse(time) || time).toLocaleString("lt");
	let altClass = "";
	let sameNickClass = "new";
	let encryptedClass = encrypted ? "enc" : "";
	if ($nameInput.value !== name) altClass = "alternate";
	if (lastName === name) sameNickClass = "same";

	const isNearBottom = $messages.scrollHeight - $messages.scrollTop - $messages.clientHeight < 80;

	text = formatText(text);
	const body = createElement('div', 'msgBody');
	body.innerHTML = text;
	if (attachment) {
		const attachmentEl = createAttachmentElement(attachment);
		if (attachmentEl) {
			body.appendChild(attachmentEl);
		}
	}
	const timeEl = createElement('p', 'time', localTimeString);
	body.appendChild(timeEl);

	const msgDiv = createElement('div', `msg ${altClass} ${sameNickClass} ${encryptedClass}`);
	msgDiv.prepend(createElement('div', 'nickname', name));
	msgDiv.appendChild(body);

	body.querySelectorAll('pre code').forEach((block) => {
		hljs.highlightBlock(block);
	});
	$messages.appendChild(msgDiv);
	if (isNearBottom) {
		$messages.scrollTop = $messages.scrollHeight;
	}
}

function openImagePreview(file) {
	if (!file || !isImageAttachment(file)) {
		return;
	}
	const dataUrl = attachmentDataUrl(file);
	$imagePreviewImage.onload = function() {
		const w = this.naturalWidth || this.width || 0;
		const h = this.naturalHeight || this.height || 0;
		$imagePreviewMeta.textContent = `${sanitizeFileName(file.name)} \u2022 ${formatBytes(file.size)} \u2022 ${w}x${h}`;
	};
	$imagePreviewImage.src = dataUrl;
	$imagePreviewOverlay.style.display = 'flex';
	$imagePreviewOverlay.setAttribute('aria-hidden', 'false');
	imagePreviewOpen = true;
}

function closeImagePreview() {
	imagePreviewOpen = false;
	$imagePreviewOverlay.style.display = 'none';
	$imagePreviewOverlay.setAttribute('aria-hidden', 'true');
	$imagePreviewImage.src = '';
	$imagePreviewMeta.textContent = '';
}

/* ===== FIREBASE ===== */
function fbAttach() {
	attachGeneration += 1;
	const currentGeneration = attachGeneration;
	messageRenderQueue = Promise.resolve();
	notificationWarmupExpiresAt = Date.now() + 17000;
	fbQuery.on('child_added', (snapshot) => {
		if (currentGeneration !== attachGeneration) {
			return;
		}
		messageRenderQueue = messageRenderQueue
			.then(() => {
				if (currentGeneration !== attachGeneration) {
					return;
				}
				return processIncomingMessage(snapshot);
			})
			.catch((err) => { console.log(err); });
	});
}

async function processIncomingMessage(snapshot) {
	const message = snapshot.val();
	if (!message) {
		return;
	}

	let isEncrypted = false;
	let displayText = message.text === undefined || message.text === null ? "" : String(message.text);
	let displayFile = sanitizeIncomingAttachment(message.file);
	if (message.enc) {
		isEncrypted = true;
		if (!password) {
			displayText = "Encrypted message. Enable encryption to decrypt.";
			displayFile = null;
		} else {
			const decryptionCandidates = [password];
			if (passwordFallback && passwordFallback !== password) {
				decryptionCandidates.push(passwordFallback);
			}
			try {
				let decryptedTextRaw;
				let lastError;
				for (let i = 0; i < decryptionCandidates.length; i++) {
					try {
						decryptedTextRaw = await decryptTextV1(message.enc, decryptionCandidates[i]);
						break;
					} catch (candidateErr) {
						lastError = candidateErr;
					}
				}
				if (decryptedTextRaw === undefined) {
					throw lastError || new Error("Decryption failed");
				}
				const { text, file } = parseDecryptedPayload(decryptedTextRaw);
				displayText = text;
				displayFile = file;
			} catch (err) {
				console.log(err);
				displayText = "Decryption failed (wrong password or corrupted data)";
				displayFile = null;
				incrementDecryptFailure();
			}
		}
	} else if (message.ct) {
		isEncrypted = true;
		displayText = "Legacy encrypted message format is no longer supported.";
		displayFile = null;
	}

	displayChatMessage(message.name, displayText, message._at, isEncrypted, displayFile);
	notifyAboutUnread();
	if (notifyEnabled && Date.now() >= notificationWarmupExpiresAt) {
		let notifyText = displayText;
		if (!notifyText && displayFile) {
			notifyText = `[Attachment] ${displayFile.name}`;
		}
		if (!notifyText) {
			notifyText = "New message";
		}
		notify(message.name, notifyText);
	}
	lastName = message.name;
}

/* ===== MESSAGING ===== */
async function send() {
	const name = $nameInput.value;
	const text = $messageInput.value;
	const hasAttachment = !!pendingAttachment;
	if (!text && !hasAttachment) return;
	if (encrypt) {
		if (!supportsModernCrypto || !password) {
			setCryptoStatusMessage("Encryption is enabled but an active password is missing.");
			return;
		}
		try {
			const encryptedPayload = await encryptPayloadV1({ text: text, file: pendingAttachment || undefined }, password);
			fb.push({ name: name, text: encryptedPayload.text, enc: encryptedPayload.enc, _at: new Date().toISOString() });
		} catch (err) {
			console.log(err);
			setCryptoStatusMessage("Failed to encrypt message.");
			return;
		}
	} else {
		const plainMessage = { name: name, text: text, _at: new Date().toISOString() };
		if (pendingAttachment) {
			plainMessage.file = pendingAttachment;
		}
		fb.push(plainMessage);
	}
	setCryptoStatusMessage("");
	clearPendingAttachment();
	$messageInput.value = '';
	$messageInput.style.height = 'auto';
	$messageInput.focus();
}

/* ===== NOTIFICATIONS ===== */
function notify(name, txt) {
	if (name === $nameInput.value) return;
	if (!("Notification" in window)) {
		alert("This browser does not support desktop notification");
	} else if (Notification.permission === "granted") {
		new Notification(txt);
	} else if (Notification.permission !== 'denied') {
		Notification.requestPermission((permission) => {
			if (permission === "granted") {
				new Notification(txt);
			}
		});
	}
}

function onVisibilityChange() {
	if (!document.hidden) {
		unreadMsgCount = 0;
		document.title = title;
	}
}

function notifyAboutUnread() {
	if (document.hidden) {
		unreadMsgCount += 1;
		document.title = `(${unreadMsgCount}) ${title}`;
	}
}

/* ===== EVENT HANDLERS & INIT ===== */
document.addEventListener('DOMContentLoaded', () => {
	$enableEncryption.checked = false;
	$persistPass.setAttribute('title', 'Persist derived unlock secret (not raw passphrase)');
	$nameInput.value = localStorage.getItem("nickname") || '';
	const storedNotify = localStorage.getItem("enableNotifications");
	if (storedNotify === null) {
		notifyEnabled = notificationsEnabled;
	} else {
		notifyEnabled = storedNotify === "true";
	}
	$enableNotifications.checked = notifyEnabled;

	fbAttach();
	document.addEventListener('visibilitychange', onVisibilityChange, false);
	if (hasPersistedSplitSecret()) {
		$enableEncryption.checked = true;
		enableEncryption();
	}
	renderPendingAttachment();
});

$enableNotifications.addEventListener('change', function() {
	notifyEnabled = this.checked;
	localStorage.setItem("enableNotifications", notifyEnabled);
});

$nameInput.addEventListener('change', function() {
	localStorage.setItem("nickname", this.value);
});

$passwordInput.addEventListener('change', () => {
	$enableEncryption.checked = false;
	encrypt = false;
	password = undefined;
	passwordFallback = undefined;
	$secureIcon.style.display = 'none';
});

$sendBtn.addEventListener('click', () => { send(); });

$attachBtn.addEventListener('click', () => { $fileInput.click(); });

$fileInput.addEventListener('change', function() {
	handleFileSelection(this.files, false);
	this.value = "";
});

$clearAttachment.addEventListener('click', () => { clearPendingAttachment(); });

$persistPass.addEventListener('click', () => { persistDerivedSecret(); });

$optionsToggle.addEventListener('click', function() {
	const expanded = this.getAttribute('aria-expanded') === 'true';
	if (expanded) {
		$options.style.display = 'none';
		this.setAttribute('aria-expanded', 'false');
	} else {
		$options.style.display = 'flex';
		this.setAttribute('aria-expanded', 'true');
	}
});

$optionsToggle.addEventListener('keydown', function(e) {
	if (e.key === 'Enter' || e.key === ' ') {
		e.preventDefault();
		this.click();
	}
});

$enableEncryption.addEventListener('change', function() {
	if (this.checked) {
		enableEncryption();
	} else {
		encrypt = false;
		password = undefined;
		passwordFallback = undefined;
		$secureIcon.style.display = 'none';
	}
});

$messageInput.addEventListener('keydown', (e) => {
	if (e.key === 'Enter' && e.ctrlKey) {
		$messageInput.value += "\n";
		e.preventDefault();
	} else if (e.key === 'Enter' && !e.ctrlKey) {
		e.preventDefault();
		send();
	}
});

$messageInput.addEventListener('input', function() {
	this.style.height = 'auto';
	this.style.height = this.scrollHeight + 'px';
});

$msgInput.addEventListener('dragenter', (e) => {
	if (!hasDraggedFiles(e)) return;
	e.preventDefault();
	e.stopPropagation();
	dragDepth += 1;
	$msgInput.classList.add('drag-over');
});

$msgInput.addEventListener('dragover', (e) => {
	if (!hasDraggedFiles(e)) return;
	e.preventDefault();
	e.stopPropagation();
});

$msgInput.addEventListener('dragleave', (e) => {
	if (!hasDraggedFiles(e)) return;
	e.preventDefault();
	e.stopPropagation();
	dragDepth = Math.max(0, dragDepth - 1);
	if (dragDepth === 0) {
		$msgInput.classList.remove('drag-over');
	}
});

$msgInput.addEventListener('drop', (e) => {
	if (!hasDraggedFiles(e)) return;
	e.preventDefault();
	e.stopPropagation();
	dragDepth = 0;
	$msgInput.classList.remove('drag-over');
	const files = e.dataTransfer ? e.dataTransfer.files : null;
	handleFileSelection(files, true);
});

document.addEventListener('dragover', (e) => {
	if (!hasDraggedFiles(e)) return;
	e.preventDefault();
});

document.addEventListener('drop', (e) => {
	if (!hasDraggedFiles(e)) return;
	e.preventDefault();
});

document.addEventListener('paste', (e) => { handlePasteAttachment(e); });

$imagePreviewClose.addEventListener('click', () => { closeImagePreview(); });

$imagePreviewOverlay.addEventListener('click', (e) => {
	if (e.target && e.target.id === 'imagePreviewOverlay') {
		closeImagePreview();
	}
});

document.addEventListener('keydown', (e) => {
	if (e.key === 'Escape' && imagePreviewOpen) {
		closeImagePreview();
	}
});

})();
		</script>
	</body>
</html>
